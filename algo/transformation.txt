Algorithme de transformation (XSL)

#### INITXSL

Définition des objets pour l'algorithme
XSL -> Document XSL parsé via le parseur
XML -> Document XML parsé via le parseur
OUT -> fichier ou flux de sortie

Récupération de l'entête depuis XML et recopie sur la sortie
XML.Document.EnTete.blabla -> OUT

Rechercher le template racine à partir du XSL
racineXSL = XSL.Document.racine.enfants.rechercher(match = "/")
si racine existe alors
    TraiterXSL (racineXSL, XML.Document.racine)
sinon
    XML.Document.racine.innerHTML -> OUT

#### FIN INITXSL

#### TraiterXML (elmtXML : ElementNoeud)
pour enfant

#### FIN TraiterXML


#### TraiterXSL (elmtXSL : ElementNoeud, elmtXML : ElementNoeud, OUT)
pour enfantXSL dans elmtXSL faire
    si enfantXSL.nom = "xsl:apply-templates" et enfant.attributs vide alors
	
	

        pour elmtFils dans elmtXML.enfants() faire
            TraiterXSL (enfant, elmtFils)
    sinon si enfantXSL.nom = "xsl:apply-templates" et enfant.attributs non vide alors

    sinon si enfantXSL.nom = "xsl:value-of" alors

    sinon si enfantXSL.nom = "xsl:for-each"

    sinon si enfantXSL.enfants() pas vide
        TraiterXSL (enfantXSL, )
    sinon si enfantXML.enfants() vide
        OUT += <enfantXSL.nom>enfant.texte</enfant.nom>

#### FIN TraiterXSL
		________________________________________________________________

//Récupération de l'entête depuis XML et recopie sur la sortie
XML.Document.EnTete.blabla -> OUT

//Partir de la racine du XML
racine = XML.document.racine
noeud = racine
racineXSL = XSL.Document.racine.enfants.rechercher(match = "/")

si racineXSL existe
	pour chaque enfant de racineXSL
		si enfantXSL.name = "xsl:apply-templates" et enfantXSL.attributs vide alors
			noeud = racine.enfant
			noeudXSL = XSL.Document.racine.enfants.rechercher(match = noeud.name)
			//on recommence le traitement pour chaque enfant de noeudXSL
		
		sinon si enfantXSL.name = "xsl:apply-templates" et enfantXSL.attributs non vide alors
			pour chaque enfant de noeud
				si enfant.noeud.name = enfantXSL.select.name alors
					noeud = noeud.enfant
					noeudXSL = XSL.Document.racine.enfants.rechercher(match = noeud.name)
					//on recommence le traitement pour chaque enfant de noeudXSL
				fin si
			fin pour
			
		sinon si sinon si enfantXSL.nom = "xsl:value-of" alors

		sinon si enfantXSL.nom = "xsl:for-each" alors
		
		sinon
			//on écrit le texte brut/avec ses balises
		fin si
	fin pour
fin si