#############################################################
#               ALGORITHME de VALIDATION                    #
#############################################################

Map type -> regex
On note qu'un seul niveau de profondeur dans la regex
Avant d'ajouter à la map, on vérifie que le type ne soit pas déjà traité.
Lorsqu'on rencontre un ref, on le traite ci nécessaire.
On traite le document XSD dans l'ordre. (on traite les fils lorsqu'on les rencontre).
On a probablement pas besoin des éléments du modèle actuel (Constructeur regex toussa).
On aura besoin d'un accès à la Map lors de l'itération afin d'ajouter les types à la volée.

1) Création des regex

Premier appel :
map = new Map()
CreationRegex(racineXSD, map)

String CreationRegex(noeudXSD, &map)
    regex = ""

    si noeudXSD.containsName() alors
        regex += '<' + noeudXSD.nom + '>'

    pour filsXSD de noeudXSD faire:
        a) élément vide
        b) élément non vide
        c) élément ref
        d) complex type
        e) choice
        f) séquence

    si noeudXSD.containsName() alors
        regex += '</' + noeudXSD.nom + '>'
        map.ajouter(noeudXSD.nom, regex)
    
    retourner regex

a) élément vide
si map.notContains(filsXSD.nom) alors
    regex += ".*"

b) élément non vide
regex += CreationRegex(filsXSD, map)

c) élément ref
regex += "@" + noeudXSD.ref + "@"
si noeudXSD.hasAttribute(minOccurs) and noeudXSD.hasAttribute(maxOccurs) alors
    regex += "{" + noeudXSD.minOccurs + ", " + noeudXSD.maxOccurs + "}"
sinon si noeudXSD.hasAttribute(minOccurs) alors
    regex += "{" + noeudXSD.minOccurs + ",}"
sinon si noeudXSD.hasAttribute(maxOccurs) alors
    regex += "{1, " + noeudXSD.maxOccurs + "}"
 
d) complex type
return CreationRegex(filsXSD, map)

e) choice
regex += "("
pour petitFilsXSD de filsXSD alors
    regex += CreationRegex(petitFilsXSD, map)
    regex += " | " -> si pas dernier fils
regex += ")"

f) séquence
regex += "("
pour petitFilsXSD de filsXSD alors
    regex += CreationRegex(petitFilsXSD, map)
regex += ")"

2) Remplacement des refs par leur regex

Dans l'algo suivant, on utilisera la fonction parseRef qui retourne
un tableau avec les noms contenus entre deux "@"

String RemplacerRefs(nom, map)

    si map[nom].contains("@") alors
        ref = parseRef()
        pour refFils de ref alors 
            si map.contains(refFils)
                regex = RemplacerRefs(refFils, map)
                map.remplacer("@" + refFils + "@", regex)
            sinon
                afficher "Impossible de trouver la référence pour " + refFils.nom
                retourner ""
    
    retouner map[nom]


pour nom, regex de map faire
    RemplacerRefs(nom, map)

3) Validation du XML avec les regex

L'algo suivant utilise une fonction qui retourne les noeuds de premier
niveau sous forme XML d'un noeud voulu. (getFirstLevel)

Premier appel :
ValiderXML(racineXML, map)

Booleen ValiderXML(noeudXML, map)
    si map.contains(noeudXML.nom) alors
        si map[noeudXML.nom] match getFirstLevel(noeudXML) alors
            pour filsXML de noeudXML faire
                booleenValider = ValiderXML(filsXML, map)
                si booleenValider est faux alors
                    retourner faux 
            retourner vrai
        sinon
            afficher "Le document n'est pas valide au niveau du noeud " + noeudXML.nom
            retourner faux
    sinon
        afficher "L'expression régulière n'est pas définie pour le noeud " + noeudXML.nom
        retourner faux
