#############################################################
#               ALGORITHME de VALIDATION                    #
#############################################################

--------------- Fonctions utiles ---------------------------

------------------Appel initial de l'algo-------------------
documentXML.ValidationXSD(documentXSD)
map = newMap()
racineXSD = documentXSD.racine
sortie = racineXSD.CreationRegex(map)

pour tout nom de map faire
	RemplacerRefs(nom, map)
fin pour

racineXML = documentXML.racine
estValide = racineXML.ValiderXML(map)
	

--------------- Méthode pour Document ---------------------------

Boolean documentXML::ValidationXSD(documentXSD) {

	map = newMap()
	racineXSD = documentXSD.racine
	sortie = racineXSD.CreationRegex(map)

	pour tout nom de map faire
		this.RemplacerRefs(nom, map)
	fin pour

	racineXML = this.racine
	estValide = racineXML.ValiderXML(map)
	
	retourner estValide
}

String documentXML::RemplacerRefs(nom, map) {

    si map[nom].contains("@") alors
        ref = parseRef()
        pour refFils de ref alors 
            si map.contains(refFils)
                regex = RemplacerRefs(refFils, map)
                map.remplacer("@" + refFils + "@", regex)
            sinon
                afficher "Impossible de trouver la référence pour " + refFils.nom
                retourner ""
    
    retouner map[nom]
}



--------------- Méthodes pour ElementNoeud ---------------------------

1) Création des regex

String ElementNoeud::CreationRegex(&map)
    regex = ""

    si this.containsName() alors
        regex += '<' + noeudXSD.nom + '>'

    pour filsXSD de this faire:
        a) élément vide
        b) élément non vide
        c) élément ref
        d) complex type
        e) choice
        f) séquence

    si this.containsName() alors
        regex += '</' + this.nom + '>'
        map.ajouter(this.nom, regex)
    
    retourner regex

a) élément vide
si map.notContains(filsXSD.nom) alors
    regex += ".*"

b) élément non vide
regex += filsXSD.CreationRegex(map)

c) élément ref
regex += "@" + this.ref + "@"
si this.hasAttribute(minOccurs) and this.hasAttribute(maxOccurs) alors
    regex += "{" + this.minOccurs + ", " + this.maxOccurs + "}"
sinon si this.hasAttribute(minOccurs) alors
    regex += "{" + this.minOccurs + ",}"
sinon si this.hasAttribute(maxOccurs) alors
    regex += "{1, " + this.maxOccurs + "}"
 
d) complex type
return filsXSD.CreationRegex(map)

e) choice
regex += "("
pour petitFilsXSD de filsXSD alors
    regex += petitFilsXSD.CreationRegex(map)
    regex += " | " -> si pas dernier fils
regex += ")"

f) séquence
regex += "("
pour petitFilsXSD de filsXSD alors
    regex += petitFilsXSD.CreationRegex(map)
regex += ")"


3) Validation du XML avec les regex

L'algo suivant utilise une fonction qui retourne les noeuds de premier
niveau sous forme XML d'un noeud voulu. (getFirstLevel)



Booleen ElementNoeud::ValiderXML(map)
    si map.contains(this.nom) alors
        si map[this.nom] match getFirstLevel(this) alors
            pour filsXML de this faire
                booleenValider = ValiderXML(filsXML, map)
                si booleenValider est faux alors
                    retourner faux 
            retourner vrai
        sinon
            afficher "Le document n'est pas valide au niveau du noeud " + this.nom
            retourner faux
    sinon
        afficher "L'expression régulière n'est pas définie pour le noeud " + this.nom
        retourner faux
